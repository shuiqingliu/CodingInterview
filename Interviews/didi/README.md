# didi java intern interview
主要问了 JAVA 的基础 ，Spring AOP  IOC ,Spring 框架的源码和 MySQL 的事务以及事务隔离级别。在此做个记录防止遗忘。
[TOC]
### 1. String,StringBuffer 和 StringBuilder 区别
* a) String 是不可变的`对象`，他一旦被创建就不能改变。已经创建的String 对象保存在`静态String池(Constant String Pool)`当中,JAVA 中每一个不可变的对象都是线程安全的，String 不能同时应用于两个线程。
* b)StringBuffer  是可以改变对象值的所以他是可变的，通过 StringBuffer 创建对象后存储在堆，StringBuffer 和 StringBuilder 有同样的方法但是 StringBuffer 中的每一个方法都是 synchronized 所以 StringBuffer 是线程安全的。由于 synchronized 锁的机制每个方法一次只能被一个线程访问。但是线程安全也有缺点，这就影响了 StringBuffer 的性能，所以当调用同一个方法是 StringBuilder 要快与 StringBuffer
* c)StringBuilder 跟StringBuffer 类似，他也将对象存储在堆并且可以被修改，最大的区别就是 StrinbBuilder 不是线程安全的。

### 2. JVM 的内存模型

* 内存结构

  ![jvm](../img/JVM.png)
  
* a) **程序计数器**（PC, Program Counter Register) : 在 JVM 中每个线程都有自己的 PC,在任何时间点每个线程都只有一个方法执行也就是所谓的当前方法，如果这个方法不是本地方法，程序计数器会存储当前线程正在执行的 JAVA 方法的 JVM 指令地址，否则 PC 为未定义值
* b)**JAVA 虚拟机栈**（JVM Stack）：每个线程有一个私有的 JVM 栈，跟线程同时创建，用来存储一个个栈桢（Stack frame). JVM 对栈的操作只有对栈桢的 pop 和 push, JVM 栈的大小可以是固定的也可以设置成随计算需求动态扩充或收缩。
> 如果是栈大小是固定大小的那么当线程所需要的栈空间大小大于允许的栈空间大小时候则抛出 `StackOverflowError`，如果栈空间是动态扩展的那么当内存不能满足扩展的需要的时候或者不足以初始化一个线程的栈的时候就会抛出 `OutOfMemoryError`

* c)**堆**(Heap): 堆被所有的线程共享。堆是运行时数据区域，几乎所有类的实例和数组都被分配到堆上，当虚拟机创建的时候堆随即被创建,对象的堆存储由自动存储管理系统回收,比较有名的就是 GC(garbage collector),当自动存储管理系统不能提供马权奇女足要求的堆空间的时候 会抛出 `OutOfMemoryError`。堆内存不需要是连续的。
* d)**方法区**（Method Area):方法区也是线程共享的内存区域， 用于存储每个类的结构信息，以及对应的运行时常量池，字段和方法数据，方法和构造器代码。运行时常量池主要存储各种常量信息，主要有编译期生成的字面量和运行时决定的符合引用。
* e)**本地方法栈**(Native Method Stacks)：用于支持本地方法调用（不是用 Java 语言写的方法），也被用于其他语言的jvm 指令集解释器的实现
* f)**栈桢**(Frames): 栈桢用来存储数据和部分结果，以及执行动态链接，返回方法值和分派异常。当每一个方法调用的时候相对应的栈桢就会被创建成为新的当前桢，当方法调用完成时栈桢也随之被销毁，而不管方法是正常完成还是抛出异常。每个栈桢有自己一系列的局部变量，操作数栈(operand stack，用于存储常量以及值的操作，也称作求值栈，涉及到一些 JVM 指令例如iadd)，和对当前线程对象的运行时常量池的引用。每一时刻只有一个活动的栈桢，称作当前桢，对应方法叫做当前方法，定义当前方法的类叫做当前类或当前对象。

### 3. GC 机制
GC 发生时候需要明确的三个问题：
> 摘自 《深入理解 Java 虚拟机》
* 哪些内存需要回收？
* 什么时候回收？
* 如何回收？

在理解如何进行 GC 之前需要了解的是内存如何分配，因为内存回收时候涉及到分代的概念。上节图示中堆分为新生代和老年代。而新生代又分为 Eden，Survivor 。
1. 大多数情况下，对象在新生代的 Eden 区分配当 Eden 区没有足够的空间进行分配的时候发生一次MinorGC,MinorGC 很频繁，发生新生代相对地还有  MajorGC/FullGC 发生在老年代，发生 MajorGC 经常会伴随至少一次 MinorGC （非绝对看收集器）关于Major GC和 Full GC 参考 R大回复(https://www.zhihu.com/question/41922036/answer/93079526)
2. 大对象直接进入老年代，就是那些需要大量连续内存空间的对象例如很长的字符串和数组。
3. 长期存活的对象将进入老年代，HotSpot 采用分代的思想管理内存，虚拟机为每个对象定义了一个 年龄(Age)计数器，当对象在 Eden 出生并经过一次 MinorGC后 仍然存活并且被 Survivor 容纳的话将被移到 Survivor空间中并且对象年龄设置为 1。对象在 Survivor中度过一次 Minor GC 年龄就增加 1，当年龄达到 阀值(默认 15)时候就进入老年代中。虚拟机并不是严格按照这个值进行判断的，这就涉及到动态对象年龄判断， 当 Survivor 中相同年龄所以对象大小总和大于 Survivor 空间一半的时候 年龄大于等于该年龄的对象就直接进入老年代。

#### 3.1哪些内存需要回收？
不可能被任何途径使用的对象需要进行回收,采用`可达性分析算法`（**当前主流的虚拟机实现中没有采用引用计数算法来管理内存的，面试时候需要注意**）可达性分析算法通过一系列的 GC Roots 对象作为起点向下搜索，搜索走过的路径成为引用链，当一个对象到 GC Roots 不可达时候则证明此对象是不可用的。（注意对象死亡的二次标记）
谁可以作为 GC Roots ?  1. 虚拟机栈（栈桢中本地变量表）中引用的对象 2. 方法区中静态属性引用的对象
#### 3.2 什么时候回收？
  当 JVM 判断内存空间不够用的时候，即实则为 Minor GC Full GC触发条件
#### 3.3 如何回收?
1. 标记-清除算法
  分为标记和清除两个阶段，标记出需要回收的对象，在标记完后统一回收标记对象
  * 缺点：标记，清除效率低，会产生大量不连续的空间碎片导致分配较大对象的时候无法找到连续的内存而触发 GC

  ![mark-remove](../img/mark-sweep.png)
  
  由上图可以看出在采用 Mark-Sweep 算法后出现了大量的碎片区域。
2. 复制算法
   该算法将内存分为两块，优先使用其中一块当其中一块使用完了就会将存活的对象复制到另外一块上面，然后将使用过的一次清理掉。
   
   ![copy](../img/copy.png)
   
   * 优点：内存分配不用考虑碎片，一次将整个半区都清理，高效实现简单。
   * 缺点：将内存缩小了原来的一半代价大。
调优：目前商业虚拟机都是采用收集算法回收内存，由于新生代的对象存活生死活跃，所以不需要按照 1:1 划分两块空间，划分如下：

![generations](../img/generation.png)

>  ps: 新生代中 Eden 和 Survivior 的比例可以通过 JVM 参数 -XX:SurvivorRation=y  设置 代表 y:1

它将新生代划分为较大 Eden，两个较小的 Survivor空间，每次使用 Eden 和 Survivor 中一块，当回收时候 将 Eden 和 Survivior 中存活的对象一次性复制到另外一块 Survivor 上，如果另外一块 Survivor 存放不下就有分配担保机制将对象存入老年代，最后清理掉 Eden 和 第一块 Survivior 。这样新生代每次可用内存为 Eden + 一个 Survivor 按比例为 90% 提高了利用率。

3. 标记-整理算法
  当对象存活过多的时候复制算法就要进行较多复制操作，如果不浪费 50% 空间就需要额外内存空间作为担保(老年代为新生代担保)，所以在老年代就不能采用复制算法，就有了 标记-整理（Mark-compact）算法提出，他不是直接对对象清理而是让存活对象向一端移动最后清理掉边界以外的内存。
   * 优点：不会产生碎片

![mark-compact](../img/mark-compact.png)

4. 分代收集

   根据对象存活周期将内存划分，一般就是新生代老年代，然后不同代选用上述不同的垃圾收集算法。

#### 3.4 垃圾收集器

垃圾收集器是垃圾收集算法的具体实现，下面简单的介绍下 HotSpot 虚拟机的垃圾收集器。
1. Serial 收集器
	单线程收集器，采用复制算法，在进行 GC 的时候会｀暂停｀所有的工作线程，直到收集结束，但是 Seiral 收集器没有线程交互的开销，可以获得最高的单线程收集效率。因为桌面应用新生代空间不是很大停顿时间很小，所以 Serial 收集器在 Client 模式下的 JVM 来说是很好的选择，Serial　收集器 还有老年代的版本 称为  Serial Old　收集器。
2. ParNew 收集器
	是 Serial 多线程版本，采用复制算法，有多个 GC 线程执行清理工作，清理新生代，他可以配合 CMS 收集器（老年代收集器）使用。
3. Parallel Scavenge 收集器
	新生代收集器，采用复制算法，无法配合 CMS 工作，专注于 吞吐量而不是GC 时用户线程停顿时间，吞吐量= 运行用户代码时间/（运行用户代码时间 + 垃圾收集时间），高吞吐量可以高效率利用 CPU 时间，响应的也有老年代版本：Parallel Old ，采用标记-整理算法。
4. CMS （Concurrent Mark Sweep）收集器
	真正意义上的并发收集器，采用标记-清除 算法，可以获得最短回收停顿时间，分为如下四个阶段：
	* 初试标记：需要停顿，速度很快只标记 GC Roots 直接关联对象
	* 并发标记：不需要停顿，跟踪 GC Roots 过程
	* 重新标记：需要停顿，修正并发标记期间因用户程序继续运作导致标记变动的那一部分对象
	* 并发清除：不需停顿，并发执行
	缺点：1.CPU 资源敏感，占用不少于 25% CPU 资源 2. 不能清理浮动垃圾,并发运行后 标记过程之后的垃圾不能清理，3. 标记-清除 产生内存碎片，可能引发 Full GC，Full GC 可以伴随着压缩动作。
5. G1 收集器
	可以清理 新生代和老年代。采用标记-整理算法不会产生碎片，能够预测停顿，通过将整个 Java 堆用大小相等的独立的区域──Region 进行划分，优先收集价值大的 Region（熬过多次 GC 的对象），JVM 用 Remembered Set 来避免全堆扫描。G1 收集大致步骤：
	* 初试标记：同 CMS，并修改 TAMS（Next Top at Mark Start）供用户程序并发运行时正确在 Region创建对象
	* 并发标记：同 CMS
	* 最终标记：同 CMS 重新标记
	* 筛选回收 ：对可回收 Region 价值排序，根据用户期望停顿时间制定回收计划。
	
### 4. Spring IOC、AOP实现原理 



### 5. Spring 如何定位到 Controller
### 6. MySQL 事务隔离基本
### 7. MySQL  索引